<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Textbus</title>
<!--  <script src="//cdn.jsdelivr.net/npm/eruda"></script>-->
<!--  <script>eruda.init();</script>-->
</head>
<body>
<div class="container">
  <div id="avatar"></div>
  <div id="editor"></div>
  <div id="log"></div>
  <div class="right">
    <div class="btn-list">
      <div>
        <button type="button">获取选区路径</button>
        <button type="button">获取 JSON 内容</button>
        <button type="button">获取 HTML 内容</button>
      </div>
      <div>
        <button type="button">复制内容</button>
      </div>
    </div>
    <div class="content">
      <textarea></textarea>
    </div>
    <div class="btn-list">
      <div>
        <button type="button">替换为框内 JSON</button>
        <button type="button">替换为框内 HTML</button>
        <button type="button">应用框内 JSON 路径</button>
      </div>
    </div>
  </div>
</div>
<div id="template" hidden><p textbus-slot-root="" textbus-component-root="" style="background-color: rgb(255, 255, 255);"><span style="font-size: 16px; font-family: Lato, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(85, 85, 85);">Textbus 是一个以组件为中心，数据驱动的富文本编辑器开发框架！为了解决传统富文本开发中遇到的各种问题，我们完全自主设计了富文本的组件系统和格式系统，旨在降低富文本的开发成本，帮助你更轻松的扩展出丰富的富文本功能。不管你是富文本开发的老鸟，亦或是前端的新手，你都将会在 Textbus 中感受到非凡的开发体验和扩展能力。</span></p><p textbus-slot-root="" textbus-component-root="" style="background-color: rgb(255, 255, 255);">赶快运行起来，看一看效果：<br></p><pre lang="TypeScript" theme="light" textbus-component-root="" class="tb-pre"><div class="tb-code-line-number-bg" style="width: 2.5em;"></div><div class="tb-code-content"><div textbus-slot-root="" class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{ createEditor }&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@textbus/editor'</span>;</div><div textbus-slot-root="" class="tb-code-line"><br></div><div textbus-slot-root="" class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;editor =&nbsp;<span class="tb-hl-function">createEditor</span>();</div><div textbus-slot-root="" class="tb-code-line">editor.<span class="tb-hl-function">mount</span>(document.<span class="tb-hl-function">getElementById</span>(<span class="tb-hl-string">'editor'</span>))</div><div textbus-slot-root="" class="tb-code-line">editor.onChange.<span class="tb-hl-function">subscribe</span>(() =&gt; {</div><div textbus-slot-root="" class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;html = editor.<span class="tb-hl-function">getHTML</span>();</div><div textbus-slot-root="" class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-builtin">console</span>.<span class="tb-hl-function">log</span>(html);</div><div textbus-slot-root="" class="tb-code-line">})</div></div><span class="tb-pre-lang">TypeScript</span></pre><p textbus-slot-root="" textbus-component-root="">为什么选择 Textbus，相较于传统的富文本编辑器，Textbus 都有什么优点呢？我们做一个简单的梳理：</p><ul textbus-component-root=""><li textbus-slot-root="" class="tb-list-item"><strong>组件化</strong>：在富文本中做交互在传统富文本中是很难的，而 Textbus 通过组件可以方便的实现在文档编辑中复杂的交互效果；</li><li textbus-slot-root="" class="tb-list-item"><strong>数据驱动</strong>：不需要手动操作 DOM 去完成文档内容的编辑，完全的数据驱动，使文档总是能得到预期的结果；</li><li textbus-slot-root="" class="tb-list-item"><strong>轻量化内核</strong>：Textbus 内核中只抽象了富文本的选区、格式转换和数据模型。没有内置任何其它的功能，你可以按你的想法完全定制；</li><li textbus-slot-root="" class="tb-list-item"><strong>高扩展能力</strong>：你不但可以添加任意样式，还可以通过组件扩展任意的功能，完成诸如钉钉文档、飞书文档、石墨文档等功能；</li><li textbus-slot-root="" class="tb-list-item"><strong>语法糖</strong>：你可以根据自己的需要扩展不限于 Markdown 之类的语法糖，让用户可以更便捷的完成格式化；</li><li textbus-slot-root="" class="tb-list-item"><strong>协作支持</strong>：通过对接 Textbus 内核，可以实现 OT 或 CRDT 多人在线协作能力；</li><li textbus-slot-root="" class="tb-list-item"><strong>高性能</strong>：由 Textbus 根据富文本场景定制的渲染器，大多数情况下，可以在 1ms 之内完成视图的渲染；</li><li textbus-slot-root="" class="tb-list-item"><strong>jsx/tsx 支持</strong>：可以通过 jsx 或 tsx 编写组件，灵活性更强，而不用学习其它的方言。</li></ul><p textbus-slot-root="" textbus-component-root="">来回顾一下 Textbus 的发展历史吧：</p><tb-timeline textbus-component-root=""><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><span class="tb-timeline-add"></span><div textbus-slot-root="" class="tb-timeline-content"><div textbus-slot-root="" textbus-component-root=""><strong style="font-size: 18px;">立项&nbsp;</strong><span style="color: rgb(119, 119, 119); font-size: 15px;">需求的起始</span></div><p textbus-slot-root="" textbus-component-root="">因当时工作需要，要 copy 一些表格或 word 文档到富文本编辑器内，同时，也希望能在富文本内做一些简单的编辑。经过一番调研，市面上的富文本要么把样式丢了，要么表格编辑功能不够，要么产出的样式很脏，会遗留很多从 word 或 excel 拷贝过来的脏数据。</p><p textbus-slot-root="" textbus-component-root="">为了先满足暂时的业务的需求，我先使用了某编辑器，同时用所有的业余时间着手展开富文本编辑器的研发工作。<br></p></div></div><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><span class="tb-timeline-add"></span><div textbus-slot-root="" class="tb-timeline-content"><div textbus-slot-root="" textbus-component-root=""><strong style="font-size: 18px;">contenteditable 的实践&nbsp;</strong><span style="color: rgb(119, 119, 119); font-size: 15px;">第一个版本</span></div><p textbus-slot-root="" textbus-component-root="">和其它富文本编辑器一样，一开始也是基于 DOM 的 contenteditable 属性。经过3个月的开发，初具雏形，但发现了一个很大的问题。</p><ol textbus-component-root=""><li textbus-slot-root="" class="tb-list-item">浏览器的行为不可控，不同的浏览器对同样的操作产出的结果不一样；</li><li textbus-slot-root="" class="tb-list-item">编辑的数据不可控。我完全不知道一个加粗操作会产生什么样的 DOM 结构；</li><li textbus-slot-root="" class="tb-list-item">产出的数据很脏，比如加粗一段文字，在经过几次操作之后，可能会同时出现多个 strong 标签并列的情况；</li><li textbus-slot-root="" class="tb-list-item">因为内容不可控，所以也并没有很好的解决从 word 或 excel 拷贝数据太脏的问题。<br></li></ol><p textbus-slot-root="" textbus-component-root="">其实问题远不止以上 4 点，但这对于我来说，是完全不能接受的。<br></p></div></div><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><span class="tb-timeline-add"></span><div textbus-slot-root="" class="tb-timeline-content"><div textbus-slot-root="" textbus-component-root=""><strong style="font-size: 18px;">数据驱动视图的探索&nbsp;</strong><span style="color: rgb(119, 119, 119); font-size: 15px;">第二个版本</span></div><p textbus-slot-root="" textbus-component-root="">这个版本完全抛弃了 contenteditable 的方案，采用自定义输入功能，重新设计了架构。采用可编辑片段（Fragment）+ 格式化信息（Formatter）的组合方式，和现在大家见到的如 Draft.js、Slate.js 类似。这种方案有一个很大的优点，生成的结果不脏了，从 word、excel 或网页拷贝过来的数据不但能保留必要的样式，冗余的数据也自动清理掉了。同时也可以很方便的实现一些特定功能，如实时代码高亮等。</p><p textbus-slot-root="" textbus-component-root="">虽然经过以上设计，解决了第一个版本的问题，但又引出的新问题，如：如何保证一个固定的结构不可编辑，同时指定某些内容是可编辑的？这是一个很常见的需求，如卡片，上面一张图片，下面一小段描述性文字。传统的编辑器是把外层设置为 contenteditable = false，内层再重置 contenteditable = true，但 Textbus 已抛弃了这种方案，不能重回老路。<br></p></div></div><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><span class="tb-timeline-add"></span><div textbus-slot-root="" class="tb-timeline-content"><div textbus-slot-root="" textbus-component-root=""><strong style="font-size: 18px;">黎明前的黑暗&nbsp;</strong><span style="color: rgb(119, 119, 119); font-size: 15px;">再一次自我否定</span></div><p textbus-slot-root="" textbus-component-root="">经过前面两次版本的经验，首先验证了两件事：</p><ol textbus-component-root=""><li textbus-slot-root="" class="tb-list-item">基于 contenteditable 的路是行不通的；</li><li textbus-slot-root="" class="tb-list-item">数据驱动是解决问题的根本之道。<br></li></ol><p textbus-slot-root="" textbus-component-root="">如果说写代码有什么事是令人痛苦的，那么我觉得就是把自己几个月辛苦的成果完全抛弃。如果说有什么是比这个是更痛苦的，那就是抛弃两次！到这个时候，我已经在富文本的研究上花了一年的时间了，最终的结果却不尽人意。如果没有从根本上解决富文本的抽象，那么我所做的一切不过是重复造轮子，最大的作用就是给自己涨一点经验。</p></div></div><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><span class="tb-timeline-add"></span><div textbus-slot-root="" class="tb-timeline-content"><div textbus-slot-root="" textbus-component-root=""><strong style="font-size: 18px;">组件化设计&nbsp;</strong><span style="color: rgb(119, 119, 119); font-size: 15px;">打开新世界的大门</span></div><p textbus-slot-root="" textbus-component-root="">我不是一个喜欢轻言放弃的人，尤其是对自己有兴趣的事情上！</p><p textbus-slot-root="" textbus-component-root="">结合我自己的经验和现代前端框架的设计，组件化是一条可行之路。但富文本因有其特殊性，肯定不能照搬前端框架的设计思路。这时，如何在富文本里做组件化，就成了决定 Textbus 成败的关键。</p><div textbus-slot-root="" textbus-component-root="">经过短时间的休整，我重新开始了富文本的探索之路。</div><p textbus-slot-root="" textbus-component-root="">我分析了现代前端框架组件的特点，都是由一段固定的 html 模板，一部分数据，再加上插槽基本就组成了一个组件的形态。而如果要在富文本里做组件，就不仅要具备以上要素，还需要提供动态编辑的能力。</p><p textbus-slot-root="" textbus-component-root="">在典型的前端应用场景里，组件树的形态和分支是可预测的，无非就是根据一些数据，填充占位符，再根据一些条件，判断展示哪一个预设的组件或 DOM 节点。富文本不是这样的。富文本所有数据的组装是不可预测的，会随着用户的添加、删除或编辑操作的变化而产生变化。</p><p textbus-slot-root="" textbus-component-root="">基于富文本的特殊需求，我重新设计组件系统。该组件系统抽象了富文本编辑操作特点，提供了统一的封装，只要继承自现有组件系统的的抽象类，就可以自动获得在 Textbus 里和其它组件的组合编辑能力。至此，Textbus 终于找到了一条正确的设计思路！</p></div></div><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><span class="tb-timeline-add"></span><div textbus-slot-root="" class="tb-timeline-content"><div textbus-slot-root="" textbus-component-root=""><strong style="font-size: 18px;">性能瓶颈的第一次考验&nbsp;</strong><span style="color: rgb(119, 119, 119); font-size: 15px;">渲染器短板</span></div><p textbus-slot-root="" textbus-component-root="">在组件化设计告一段落之后，我信心十足，以为 Textbus 迎来了春天，但打脸接踵而至。我发现 Textbus 很容易就遇到性能问题，由于 Textbus 的视图是由数据驱动的，随着编辑内容的增长，更新所需的 diff 时间就会越长，我习惯性的在每一个函数的开始调用和结束调用的地方加上时间戳，发现每一个函数所花费的时间并不长。我又仔细梳理了视图更新的流程，在当前的架构下，也没有哪一步计算是多余的。一时间，我陷入了沉默，因为直觉告诉我，Textbus 又要大改了。</p><p textbus-slot-root="" textbus-component-root="">然而，性能优化谈何容易，近两个月的时间，我都没有思考出一个较好的方案。<br></p></div></div><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><span class="tb-timeline-add"></span><div textbus-slot-root="" class="tb-timeline-content"><div textbus-slot-root="" textbus-component-root=""><strong style="font-size: 18px;">可维护性的升级&nbsp;</strong><span style="color: rgb(119, 119, 119); font-size: 15px;">剪不断，理还乱</span></div><p textbus-slot-root="" textbus-component-root="">又过了一段时间，当我把渲染性能问题解决了之后，这时，Textbus 官方群里的小伙伴也越来越多了，由于当时并没有很好的文档，很多小伙伴会提出一些问题。有时，我可能回答得不及时，有的小伙伴都自己去看源代码去了。</p><p textbus-slot-root="" textbus-component-root="">反馈接着就来了，一部分群友表示，源代码太复杂，看不懂！</p><p textbus-slot-root="" textbus-component-root="">这不得不说，因为 Textbus 一直处于探索之中，想用最短的时间验证设计思路和可行性，所以源代码的组织架构上，还存在不少短板。又因为富文本编辑器本身的复杂度较高，导致各个类之间存在的复杂的引用关系。要解决这个问题，还需要从设计上入手，为此，专门写了一套依赖注入的库，即&nbsp;<a target="_blank" data-href="https://github.com/tbhuabi/di">@tanbo/di</a>&nbsp;，通过依赖注入的方式，实现了各个类之间的解耦。</p><p textbus-slot-root="" textbus-component-root="">至此，Textbus 发布 1.0.0 的 alpha 版本。<br></p></div></div><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><span class="tb-timeline-add"></span><div textbus-slot-root="" class="tb-timeline-content"><div textbus-slot-root="" textbus-component-root=""><strong style="font-size: 18px;">2.0 的诞生</strong><span style="color: rgb(119, 119, 119); font-size: 15px;">&nbsp;再一次降低复杂度</span></div><p textbus-slot-root="" textbus-component-root="">随着后续 1.0 版本的正式发布，我同样把装饰器带到了组件，虽然代码看上去更整洁了，但对大多数小伙伴来说，编写 Textbus 的扩展也需要学习装饰器和 TypeScript。这对于上手成本还是过高，另外，原来一直和大家承诺的在线协作能力也一直没有实现。</p><p textbus-slot-root="" textbus-component-root="">痛定思痛，我决定在 1.0 的经验之上，更进一步。</p><p textbus-slot-root="" textbus-component-root="">新版本并没有完全按照 1.0 的设计，而是把协作作为基础设计目标，同时，结合现代前端框架 hooks 的特点，重新设计。要求，新的版本不但能降低扩展难度，同时，也不绑定装饰器和 TypeScript。在经过一年时间的开发、测试终于发布的 2.0 正式版。</p></div></div><div class="tb-timeline-item tb-timeline-item-primary"><div class="tb-timeline-line"></div><div title="null" class="tb-timeline-icon"></div><span class="tb-timeline-add"></span><div textbus-slot-root="" class="tb-timeline-content"><div textbus-slot-root="" textbus-component-root=""><strong style="font-size: 18px;">未来展望</strong><span style="color: rgb(119, 119, 119); font-size: 15px;">&nbsp;3.0</span></div><p textbus-slot-root="" textbus-component-root="">随着 2.0 版本的稳定，Textbus 基本达到的预设的目标，并且完成得很好，我们将再接再厉，持续优化，并积极吸取广大用户的意见和建议，为大家提供更好用的富文本基础设施。</p><p textbus-slot-root="" textbus-component-root="">目前 3.0 的一些改动已在内部开发当中，预计这一个版本不会有太大改变，主要还是在 2.0 的基础上进一步优化，让我们一起期待！</p></div></div></tb-timeline><p textbus-slot-root="" textbus-component-root="">这就是 Textbus 的诞生之路，事情往往不会一帆风顺，作为作者，我能做的也只有一直坚持不懈。Textbus 并不完美，还继续探索下去，这里也感谢 Textbus 的使用者对 Textbus 的支持与包容！</p><p textbus-slot-root="" textbus-component-root="">我们再来看看 Textbus 中一些核心的概念吧：<br></p><tb-word-explain textbus-component-root=""><div class="tb-word-explain-title-group"><div textbus-slot-root="" class="tb-word-explain-title" style="text-align: right;"><code>Component</code><br></div><div textbus-slot-root="" class="tb-word-explain-subtitle" style="text-align: right;">组件<br></div></div><div textbus-slot-root="" class="tb-word-explain-detail">Textbus 的组件和传统 web 开发中的组件其实是差不多的，由一部分相对固定的模板和动态的插槽组成。<br></div><span class="tb-word-explain-close"></span></tb-word-explain><tb-word-explain textbus-component-root=""><div class="tb-word-explain-title-group"><div textbus-slot-root="" class="tb-word-explain-title" style="text-align: right;"><code>ComponentLoadder</code><br></div><div textbus-slot-root="" class="tb-word-explain-subtitle" style="text-align: right;">组件加载器<br></div></div><div textbus-slot-root="" class="tb-word-explain-detail">用于把 DOM 树转换为 Textbus 组件类的转换器。<br></div><span class="tb-word-explain-close"></span></tb-word-explain><tb-word-explain textbus-component-root=""><div class="tb-word-explain-title-group"><div textbus-slot-root="" class="tb-word-explain-title" style="text-align: right;"><code>Slot</code></div><div textbus-slot-root="" class="tb-word-explain-subtitle" style="text-align: right;">可编辑片段</div></div><div textbus-slot-root="" class="tb-word-explain-detail">一段可编辑的内容，可以是字符串或组件。同时，Slot 还保存对应内容的样式。<br></div><span class="tb-word-explain-close"></span></tb-word-explain><tb-word-explain textbus-component-root=""><div class="tb-word-explain-title-group"><div textbus-slot-root="" class="tb-word-explain-title" style="text-align: right;"><code>Formatter</code><br></div><div textbus-slot-root="" class="tb-word-explain-subtitle" style="text-align: right;">格式化类</div></div><div textbus-slot-root="" class="tb-word-explain-detail">在输入时，用于读取 HTML 的样式。在输出时，用于渲染 Slot 的样式并生成虚拟 DOM。<br></div><span class="tb-word-explain-close"></span></tb-word-explain><p textbus-slot-root="" textbus-component-root="">更多的内容请查看文档，如果你的疑问，你还可以加入我们的官方 QQ 群，和核心开发人员直接提出需求，我们会尽最大努力满足：</p><p textbus-slot-root="" textbus-component-root="" style="text-align: center;"><img src="/img/qq-group.f5d2e375.png" textbus-component-root="" class="tb-img" style="width: 252px; height: auto;"></p><p textbus-slot-root="" textbus-component-root="">好了，简单的介绍就到这里为止吧，希望你使用愉快！</p><p textbus-slot-root="" textbus-component-root="" style="text-align: right;">——Textbus 开发团队</p><p textbus-slot-root="" textbus-component-root="" style="text-align: right;">2022 年 9 月 24 日<br></p>
</div>
</body>
</html>

